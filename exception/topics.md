1. Исключительные ситуации. Их важное применение.
2. Исключительные ситуации vs код возрата ошибки. Когда полезно применять код возрата ошибки.
3. Класс std::exception. Виртуальный метод what.
4. Блоки try catch.
5. throw как генерация исключения.
6. Получение объекта исключения по константной ссылке. Почему?).
7. Порядок написания блоков catch.
8. Блок catch(...) как способ обработать все исключение.
9. Что такое раскрутка стека при генерации исключения. Что будет если при генерации исключения не будет найден подходящий блок catch.
10. Что такое инвариантность при генерации исключения в конструкторе.
11. Правило написания инвариантности при написании например operator =.
12. Важность исключения при написании арифметического класса в перегруженных функциях operator += -= *= /= и т.д.
13. Smart pointers как способ избежать утечки ресурсов при генерации исключения.
14. Исключение не должно покидать Деструктор
15. Ключевое слово noexcept. Все деструкторы по умолчанию как noexcept.
16. noexcept(expression)
17. Оптимизация при написании функций как noexcept. Важность написания перемещающего конструктора как noexcept, на примере std::vector. Почему std::vector выбирает при реалокации копирующее поведение как дефолтное, вместо перемещающей семантики(правило инвариантности).
18. Компиляция кода с флагом -fno-exceptions, возможные опастности.
19. new(std::nothrow) как способ использования оператора new который не кидает исключения.